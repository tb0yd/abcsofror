---
layout: letter
title: D is for databases
subtitle: Your app's most important external dependency
permalink: d.html
---

####Introducing the shell

Rails doesn't come with a database built-in, but instead offers an interface to your database via the Unix shell. You can run shell commands on the Linux or OS X terminal, or on Windows using Cygwin. 

In this guide (and many other websites), shell commands are prefixed by a dollar sign in order to distinguish them from Ruby code. The dollar sign is not part of the command.

####Setup

The command for setting up your development database is:

    $ rake db:create

If you want to set up databases for other environments, you can do so using the environment variable RAILS_ENV:

    $ RAILS_ENV=test rake db:create

Or, you can set them all up at once:

    $ rake db:create:all

####Migrations

Migrations are a way to change the _schema_, or structure of your database. For example, the following command:

    $ rails g migration CreatePostsTable

...prints this output:

      invoke  active_record
      create    db/migrate/20120516155552_create_posts_table.rb

...and creates this migration file:

{% highlight ruby %}
    class CreatePostsTable < ActiveRecord::Migration
      def change
      end
    end
{% endhighlight %}

You can then write Rails code in this file that alters your database.

{% highlight ruby %}
    class CreatePostsTable < ActiveRecord::Migration
      def change
        create_table :posts do |t|
          t.string :title
          t.text :body
        end
      end
    end
{% endhighlight %}

You can run this migration like this:

    $ rake db:migrate

Migrations can also be reverted.

    $ rake db:migrate:down VERSION=20120516155552

####Shell shock

Depending on your background, you may not be used to running so many commands from the shell. It may be the first time you've ever opened a shell. You may still be trying to get "rake" to work on Cygwin, or trying to install the MySQL dev package on your Linux distro, or just pasting random exceptions into Google hoping that something makes your errors go away. On the other end, you might be saying, "Why learn this annoying and complicated language SQL? Why can't I use CouchDB, Redis, or simply store everything in files like a Windows application?" In contrast, if you're a SQL expert, you might be saying, "Why do I have to use ActiveRecord to generate SQL queries? Why can't I just write all my SQL myself?"

It may seem like a lot of unnecessary yak-shaving, and perhaps in some cases it is. But there are good historical reasons why this has to be.

####From orchestra to one-man band

Web development has an undeserved reputation of being only for amateurs, while in reality, it is extremely complex; perhaps more complex than Windows or iOS development. That is because unlike developing for Mac OS, Windows, or Android, where all of your tools are documented and maintained by one company, you are trying to cobble together an application from dozens of technologies that were all written by different groups at different times. 

That said, a full-featured web application was previously only possible for large companies with budgets that could encompass sysadmins, DBAs, front-end developers, back-end developers, testers, and senior architects to tie it all together. With Rails every one of those roles can be effectively played by the back-end developer. 

At my first company, our team included Java developers, Javascript developers, DBAs, UI designers, Rails developers, and two senior architects. I myself was hired as a Javascript programmer, and only learned Rails when the company decided they didn't need to write any more Javascript. After we switched to an all-Rails stack, I saw a twelve-person dev team shrink to essentially one person (not me) doing 95% of the work.

So don't think of it as unnecessary yak-shaving -- understand that you are simply doing the work of up to twelve people.
